    valid_cells = []  # List to store coordinates of cells containing more than the threshold values

    for i in range(32):
        for j in range(32):
            if np.count_nonzero(data[i, j, :] > 5) > threshold:
                valid_cells.append((i, j))

    if not valid_cells:
        print(f"No cells containing more than {threshold} values found.")
        return

    # Find the minimum bounding rectangle for all valid cells
    min_i = min(cell[0] for cell in valid_cells)
    max_i = max(cell[0] for cell in valid_cells)
    min_j = min(cell[1] for cell in valid_cells)
    max_j = max(cell[1] for cell in valid_cells)

    # Extract the smallest 2D array containing all valid cells
    selected_array = data[min_i:max_i + 1, min_j:max_j + 1, :]

    # Print the size of the selected 2D array
    print(f"Selected 2D Array Size: {selected_array.shape[:2]}")

    # Compute cross-correlations within the selected 2D array
    selected_size = selected_array.shape[:2]
    cross_corr_array = np.zeros((selected_size[0] * selected_size[1], selected_size[0] * selected_size[1]))  # Initialize array for cross-correlations

    # Create labels for cells (s1, s2, ..., sn)
    cell_labels = [f's{i+1}' for i in range(selected_size[0] * selected_size[1])]

    # Map each cell's label to its position in the array
    label_to_position = {label: (i // selected_size[1], i % selected_size[1]) for i, label in enumerate(cell_labels)}

    for i in range(selected_size[0] * selected_size[1]):
        for j in range(i, selected_size[0] * selected_size[1]):
            label_cell1, label_cell2 = cell_labels[i], cell_labels[j]
            position_cell1, position_cell2 = label_to_position[label_cell1], label_to_position[label_cell2]

            values_cell1 = pd.Series(selected_array[position_cell1[0], position_cell1[1], :])
            values_cell2 = pd.Series(selected_array[position_cell2[0], position_cell2[1], :])

            cross_corr = values_cell1.corr(values_cell2)
            cross_corr_array[i, j] = cross_corr
            #cross_corr_array[j, i] = cross_corr  # Mirror values across the diagonal

    # Normalize cross-correlation values to be in the range of -1 to 1
    #cross_corr_array = cross_corr_array / np.max(np.abs(cross_corr_array))

    # Plot the cross-correlation array
    plt.figure(figsize=(12, 10))
    plt.imshow(cross_corr_array, cmap='viridis', vmin=-1, vmax=1, interpolation='none')

    # Annotate the plot with cross-correlation values
    for i in range(selected_size[0] * selected_size[1]):
        for j in range(selected_size[0] * selected_size[1]):
            if cross_corr_array[i, j] != 0:
                fontsize = min(8, 1600 / max(selected_size[0], selected_size[1]))  # Adjust fontsize dynamically
                plt.text(j, i, f'{cross_corr_array[i, j]:.2f}', color='white',
                         ha='center', va='center', fontsize=fontsize)

    plt.xticks(np.arange(selected_size[0] * selected_size[1]), cell_labels, rotation='vertical')
    plt.yticks(np.arange(selected_size[0] * selected_size[1]), cell_labels)
    plt.colorbar(label='Cross-correlation')
    plt.title('Cross-correlation of Line Graphs between Corresponding Cells')
    plt.xlabel('Cell Label')
    plt.ylabel('Cell Label')
    plt.show()
